{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "sparkles",
  "type": "registry:ui",
  "title": "Sparkles",
  "description": "A sparkle animation.",
  "dependencies": [
    "motion",
    "lucide-react",
    "class-variance-authority"
  ],
  "files": [
    {
      "path": "registry/animations/sparkles/index.tsx",
      "content": "import * as React from \"react\";\n\nexport enum Easing {\n  LINEAR = \"linear\",\n  EASE_IN = \"ease-in\",\n  EASE_OUT = \"ease-out\",\n  EASE_IN_OUT = \"ease-in-out\",\n}\n\ninterface SparklesProps extends React.HTMLAttributes<HTMLDivElement> {\n  sparkColor?: string;\n  sparkSize?: number;\n  sparkRadius?: number;\n  sparkCount?: number;\n  duration?: number;\n  easing?: Easing;\n  extraScale?: number;\n  children?: React.ReactNode;\n}\n\ninterface Spark {\n  x: number;\n  y: number;\n  angle: number;\n  startTime: number;\n}\n\nconst Sparkles: React.FC<SparklesProps> = ({\n  sparkColor = \"#fff\",\n  sparkSize = 10,\n  sparkRadius = 15,\n  sparkCount = 8,\n  duration = 400,\n  easing = Easing.EASE_OUT,\n  extraScale = 1.0,\n  children,\n  ...props\n}) => {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const sparksRef = React.useRef<Spark[]>([]);\n  const startTimeRef = React.useRef<number | null>(null);\n\n  React.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const parent = canvas.parentElement;\n    if (!parent) return;\n\n    let resizeTimeout: NodeJS.Timeout;\n\n    const resizeCanvas = () => {\n      const { width, height } = parent.getBoundingClientRect();\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n      }\n    };\n\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(resizeCanvas, 100);\n    };\n\n    const ro = new ResizeObserver(handleResize);\n    ro.observe(parent);\n\n    resizeCanvas();\n\n    return () => {\n      ro.disconnect();\n      clearTimeout(resizeTimeout);\n    };\n  }, []);\n\n  const easeFunc = React.useCallback(\n    (t: number) => {\n      switch (easing) {\n        case Easing.LINEAR:\n          return t;\n        case Easing.EASE_IN:\n          return t * t;\n        case Easing.EASE_IN_OUT:\n          return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        default:\n          return t * (2 - t);\n      }\n    },\n    [easing],\n  );\n\n  React.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    let animationId: number;\n\n    const draw = (timestamp: number) => {\n      if (!startTimeRef.current) {\n        startTimeRef.current = timestamp;\n      }\n      ctx?.clearRect(0, 0, canvas.width, canvas.height);\n\n      sparksRef.current = sparksRef.current.filter((spark: Spark) => {\n        const elapsed = timestamp - spark.startTime;\n        if (elapsed >= duration) {\n          return false;\n        }\n\n        const progress = elapsed / duration;\n        const eased = easeFunc(progress);\n\n        const distance = eased * sparkRadius * extraScale;\n        const lineLength = sparkSize * (1 - eased);\n\n        const x1 = spark.x + distance * Math.cos(spark.angle);\n        const y1 = spark.y + distance * Math.sin(spark.angle);\n        const x2 = spark.x + (distance + lineLength) * Math.cos(spark.angle);\n        const y2 = spark.y + (distance + lineLength) * Math.sin(spark.angle);\n\n        ctx.strokeStyle = sparkColor;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n\n        return true;\n      });\n\n      animationId = requestAnimationFrame(draw);\n    };\n\n    animationId = requestAnimationFrame(draw);\n\n    return () => {\n      cancelAnimationFrame(animationId);\n    };\n  }, [\n    sparkColor,\n    sparkSize,\n    sparkRadius,\n    sparkCount,\n    duration,\n    easeFunc,\n    extraScale,\n  ]);\n\n  const handleClick = (e: React.MouseEvent<HTMLDivElement>): void => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const now = performance.now();\n    const newSparks: Spark[] = Array.from({ length: sparkCount }, (_, i) => ({\n      x,\n      y,\n      angle: (2 * Math.PI * i) / sparkCount,\n      startTime: now,\n    }));\n\n    sparksRef.current.push(...newSparks);\n  };\n\n  return (\n    <div className=\"relative w-full h-full\" onClick={handleClick} {...props}>\n      <canvas\n        ref={canvasRef}\n        className=\"absolute inset-0 pointer-events-none w-full h-full\"\n      />\n      {children}\n    </div>\n  );\n};\n\nexport default Sparkles;\n",
      "type": "registry:ui",
      "target": "components/targetblank/animations/sparkles.tsx"
    }
  ]
}